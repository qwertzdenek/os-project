% ==========================
% ŠABLONA XETEX ČLÁNEK
% ==========================


\documentclass[a4paper,12pt]{article}

% ==========================
%	Balíčky
% ==========================
%\usepackage[czech]{babel}		% nastavení češtiny (dělení slov, odstavce, nadpisy, datumy...)
%\usepackage[utf8x]{inputenc}		% nastavení vstupního kódování na UTF8
%\usepackage[T1]{fontenc}		% kodování fontu pro výsledný dokument

\usepackage{listings}
\lstset{language=C++, numbers=left, backgroundcolor=\color{Azure}}

% podpora jazyků
\usepackage{polyglossia}

% pro použití obrázků
%\usepackage[pdftex]{graphicx}			

% pro podporu výpisů programu
\usepackage{listings}	

\usepackage{hyperref}

% pro definování vlastních barev - lepší než color
\usepackage[svgnames]{xcolor}						

% pro více obrázků u sebe s jednou popiskou
\usepackage{subcaption}		

% matematika vlepší a abstraktnější verzi
\usepackage{amsmath}

% ==========================
%	Nastavení
% ==========================			

\graphicspath{ {./obrazky/} }

% počeštění názvu výpisu kódů
\renewcommand{\lstlistingname}{Kód}



\definecolor{bluekeywords}{rgb}{0.13,0.13,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.9,0,0}


\lstdefinestyle{sharpc}{
	language=[Sharp]C, 
	tabsize=4,
	keywordstyle=\color{blue}}

\lstset{style=sharpc}



% vycentrování obsahu všech floatů
\makeatletter
\g@addto@macro\@floatboxreset\centering
\makeatother

% vlastní dělení slov
\hyphenation{vy-ge-ne-ro-va-ných}


% ==============================
%	Začátek dokumentu
% ==============================
\begin{document}

% ==============================
%	Titulní strana
% ==============================
\begin{titlepage}

\sffamily	% odtud se píše bezpatkovým písmem

	\begin{center}
		\begin{Large}
		
		Západočeská univerzita v Plzni

		\vspace*{0.2cm}
		
		Fakulta aplikovaných věd

		\vspace*{0.2cm}
		
		Katedra informatiky a výpočetní techniky
		
		\vspace*{5mm}

		% vložení loga ZČU	
		\includegraphics[width=0.25\textwidth]{obrazky/logo_zcu}	
		
		\vspace*{2cm}
		
		% Název předmětu
		{\Huge\bfseries Semestrální práce z předmětu Operační systémy}

		\vspace*{1cm}
		
%		% Název úlohy
		{\bfseries SMP}
		\end{Large}
	\end{center}
	
	% vyplní mezerami do konce stránky
	\vfill

	% vloží čáru o tloušťce 0,4 pt (tloušťka kartonu)
	\hrule
	
	\vspace*{0.2cm}	
	
	% neodsazovat první řádku kontaktu
	\noindent
	Zdeněk Janeček \\ 
	david.fido.fiedler@gmail.com \\
	A14N0111P \\
	Plzeň, \number\day. \number\month. \number\year

	\vspace*{0.2cm}	
	
	\noindent
	David Fiedler \\ 
	david.fido.fiedler@gmail.com \\
	A14N0111P \\
	Plzeň, \number\day. \number\month. \number\year
	
	\vspace*{0.2cm}	
	
	\noindent
	Tomáš Cígler \\ 
	david.fido.fiedler@gmail.com \\
	A14N0111P \\
	Plzeň, \number\day. \number\month. \number\year

\rmfamily	% odtud se opět píše patkovým písmem

\end{titlepage}


\section{Zadání}

\section{Návrh}

\section{Řešení}

\subsection{Virtuální SMP}
Spouštění procesoru probíhá obdobně jako u reálného procesoru. Vstupem je procedura
\verb+hardware_start+. Nejdříve se inicializuje
systém obsluh přerušení. Každé přerušení je mapováno na samostatný Handler
hostitelského systému. Použil jsem úplně základní Event. Ten je v počátečním stavu
nesignalizovaný. Každé přerušení lze také zamaskovat a má svojí obslužnou rutinu.

V naší aplikaci jsou k dispozici následují přerušení.

\begin{description}
\item{INT\_SCHEDULER} Přepnutí plánovače. Běží typicky na prvním procesoru. Ostatní
jádra mají toto přerušení zamaskované.
\item{INT\_RESCHEDULE} Přepnutí úlohy na procesoru. Přerušení očekává adresu
zásobníku v příslušné zprávě.
\item{INT\_CORE\_TERM} Ukončení jádra.
\item{INT\_CORE\_RESUME} Opětovné spuštění. Používá plánovač.
\item{INT\_CORE\_SUSPEND} Pozastavení jádra.
\end{description}

Prvním vzniklým vláknem je vlákno hardwarového přerušení, které slouží k signalizaci
plánovače. Stará se také o životní cyklus celé simulace SMP. Toto vlákno simuluje
fyzické zapojení a tedy běží s nejvyšší prioritou.

Každé jádro má svoje vlákno obsluhy přerušení. To odpovídá hodinám, kde nebyly třeba
ve své původní podobě, protože instrukce obslužného jádra běží nezávisle na hodinách
jako nativní kód. Při inicializaci vlákna obsluhy přerušení vznikne, také fyzické jádro.

Dále se inicializuje plánovač. To je také první úloha, která se spustí na prvním procesoru.
Plánovač si vytvoří základní kontext, ze kterého pak vznikají další odvozené. Mimo inicializace
paměti vytvoří první přerušení plánovače. Plánovač zavede první jádro a začně provádět
svůj kód. Více o plánovači v další části.

Vypnutí procesoru zajistí procedura \verb+power_button+. Ve skutečnosti vznikne event,
nakterý obslužné vlákno hardwarového přerušení zareaguje a rozešle sadu přerušení pro
ukončení všech jader. Jakmile je procesor ukončen, provede ukončení všech otevřených
handlerů přerušení.

\subsection{Obsluha přerušení}
V předchozí sekci jsem se již zmínil o technickém provedení přerušení. Využím tedy systémové
události, na které čekám pomocí \verb+WaitForMultipleObjects+. Některá přerušení mají
obsluhu, která běží na cílovém procesoru, ale některá slouží k ovládání jádra.
V této aplikaci jsme si vystačili s obsluhou plánovače a přeplánování.

Přerušení plánovače nejdříve získá vnitřní zámek plánovače aby nedocházelo k souběhu
se některým systémovým voláním. Pak pozastaví všechna jádra a uloží jejich kontext.
Díky tomu je možné přeskládat úlohy s jejich aktuálním stavem. Kontext na zásobníku
obsahuje návratovou adresu tj. následující instrukce úlohy, stavové vlajky a pak všechny
registry v pořadí jak je vyžaduje instrukce \texttt{popad}.

\subsection{Plánovač}
Organizace dat.
Strategie.
Služby: vytvoření tasku, end task callback, core pause/resume.

\subsection{Životní cyklus úlohy}
Kde se nachází v plánovači.
Napojení na předchozí kapitolu v příkladech.

\subsection{Systémová volání}
Princip.
Vysvětlenní třeba task\_common\_pointers

\subsection{Synchronizační primitiva}
Pro potřeby jak úloh, tak vnitřních struktur bylo potřeba implementovat vlastní
semafor. Knihovní funkce totiž nefungují. Z pohledu systému máme pouze 4 vlákna
procesoru, ale ve skutečnosti synchronizujeme mezi neexistujícími úlohami.

Definovali jsme tedy strukturu \texttt{semaphore\_t}, která uchovává aktuální hodnotu
semaforu. Vzhledem k tomu že jde o celočíselnou hodnotu, je přiřazení atomické (pokud je
zaručeno zarovnání). Pro jistotu jsem ještě přidal prefix volatile.

Zkoušel jsem použít C++11 atomic volání, ale to jsem opustil, protože docházelo
k nevysvětlitelnému chování \verb+__RTC_CheckEsp+, které je vkládáno. Tělo takového
zámku je v následujícím výpisu. Nechávám zde pro snažší pochopení Assemblerové
implementace.

\begin{lstlisting}
int semaphore_P(semaphore_t &s, int value)
{
	int expected;
	int old;

	do {
		do {
			old = s._value;
			expected = old - value;
		} while (expected < 0);
	} while (!s._value.compare_exchange_weak(
		old, expected,
		std::memory_order_release,
		std::memory_order_relaxed));

	return expected;
}
\end{lstlisting}

Kód semaforu byl použit následující (\texttt{synchro.cpp}):

\lstset{language=[x86masm]{Assembler}}

\begin{lstlisting}
spin:
	mov edx, s
	mov edx, [edx]s._value
	mov ebx, edx
	sub ebx, value
	js spin

	mov eax, edx
	; eax - old, actual [s], ebx - expected
	mov ecx, s
	lock cmpxchg[ecx]s._value, ebx
	jnz spin
	mov result, ebx
\end{lstlisting}

\lstset{language=C++}

Vzhledem k tomu že jsem cílil na x86, mohl jsem použít inline assembly
a obalit standardní funkcí.

Uvolnění hodnoty semaforu je jednoduché:

\begin{lstlisting}
void semaphore_V(semaphore_t &s, int value)
{
	s._value += value;
}
\end{lstlisting}

\section{Vzorové úlohy}

\section{Závěr}
Při vypracování této úlohy jsme narazili na mnoho problémů, které je třeba
řešit a prozkoumali jsme základní úlohu operačního systému a to sdílení réalného času.
Využili jsme jak vysokoúrovňového C++, tak Assembleru. Zaměřili jsme se na starší
archetekturu Intel x86, protože nevyužívá velké množství registrů než 64 bitová
následovník. Z tohoto důvodu zmizely zásadní instrukce \texttt{popad} a \texttt{popfd},
které přečtou zásobník a přepíší registry. Na reálném procesoru je obsluha přerušení řešena
hardwarově a proto je možné obsluhovat s takovou rychlostí.

Bylo třeba dát si pozor co skutečně překladač vytvoří. Narazil jsem na problém, když jsem
měl nastavený malý zásobník a překladač tiše předpokládal větší. Pak nastalo k překryvu
adresního prostoru zásobníku a datového segmentu. Překladač totiž zahrnuje do kódu různé
čištění paměti pomocí instrukce \verb+rep stos+. Všechny takové chyby se vždycky projeví
později na nečekaném místě.

\begin{thebibliography}{9}

\bibitem[1]{Wikibooks}
{\em Wikipedia contributors} \\
{\bf "LaTex" Wikibooks - open book for an open world} \\
\url{http://en.wikibooks.org/wiki/LaTeX} \\

\end{thebibliography}

\end{document} 

